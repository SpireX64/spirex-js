[⮜ 01 – Задачи](./01_TASKS.md) ● [Индекс](./README.md) ● [03 – Процесс ⮞](./02_PROCESS.md)

# 2. Процесс инициализации

За управление и выполнение задач отвечает класс процесса инициализации `AppBoot`.
В приложении можно иметь несколько процессов, со своими уникальными задачами.
`AppBoot` позволяет отслеживать выполнение или провал конкретной задачи.

## 2.1. Создание процесса инициализации
Процесс инициализации создается с помощью класса `AppBoot`.
С помощью этого класса можно сконфигурировать и запустить процесс инициализации.

```ts
// Создан новый процесс инициализации
const boot = new AppBoot();
```

## 2.2. Добавление задач в процесс
Процесс должен выполнять какую либо полезную работу.
В качестве полезной работы выступают задачи,
которые содержат в себе необходимый исполнительный код.

### 2.2.1 Добавление одной задачи
Можно добавить задачу с помощью метода `add(...)`.

```ts
const task = AppBoot.task(() => {
    // логика задачи
});

// Создаем процесс
const boot = new AppBoot();

// Добавляем задачув процесс
boot.add(task);
```

Метод возвращает ссылку на `AppBoot`,
поэтому можно продолжать цепочку вызовов на добавление:

```ts
const boot = new AppBoot()
    .add(taskA)
    .add(taskB);
```

Если случайно добавить задачу 2+ раз,
это добавление будет проигнорировано
ради избежания ошибок во время инициализации.

### 2.2.2 Добавление списка задач
Чтобы не добавлять задачи по одной, можно сразу передать список:
```ts
const boot = new AppBoot().add([
    taskA, taskB,
]);
```

### 2.2.3 Условное добавление задач
Некоторые задачи нужны в определенных условиях, например,
только при разработке (dev), тестировании (stage) или продакшене (prod).

Для этого можно обернуть вызов метода `add` в условие:
```ts
const devTask = AppBoot.task(() => {});
const boot = new AppBoot();

const isDev = process.env.NODE_ENV === 'development'; 
if (isDev) 
    boot.add(devTask);
```

Этот способ разрывает цепочку вызовов.
Чтобы этого избежать, можно переместить условие в параметр метода `add`:
```ts
const devTask = AppBoot.task(() => {});
const isDev = process.env.NODE_ENV === 'development';

const boot = new AppBoot()
    .add(isDev && devTask)
```

Это возможно так как add принимает, но игнорирует значения:
`false`, `null` и `undefined`.


## 2.3 Проверка вхождения задачи в процесс
Можно убедиться, что задача присутствует в процессе, с помощью метода `has':

```ts
const taskA = AppBoot.task(() => {});
const taskB = AppBoot.task(() => {});

const boot = new AppBoot().add(taskA);

console.log(
    boot.has(taskA), // true
    boot.has(taskB), // false
)
```

Это возможность будет полезна для
динамической сборки процесса и тестирования.

## 2.4. Недостижимые задачи
При добавлении задач, `AppBoot` проверяет достижимость задач.

Достижимость задачи - это когда сама задача
и ее зависимости добавлены в процесс.

```ts
const taskA = AppBoot.task(() => {});
const taskB = AppBoot.task(() => {}, [ taskA ]);
const taskC = AppBoot.task(() => {});
const taskD = AppBoot.task(() => {}, [ taskA, taskC ]);

// Не добавляем задачу `taskC'
const boot = new AppBoot()
    .add([ taskA, taskB, taskD ]);

```
- `taskA` - достижимая, есть в процессе, нет зависимостей;
- `taskB` - достижимая, есть в процессе, зависимость `taskA` тоже в процессе;
- `taskC` - недостижимая, отсутствует в процессе;
- `taskD` - недостижимая, зависимость `taskC` отсутствует в процессе.

Недостижимые задачи будут исключены из процесса инициализации,
чтобы избежать бесконечного ожидания выполнения их зависимостей.

Если в процессе есть недостижимые обязательные задачи,
то процесс кинет ошибку при попытке его запуска.

### 2.4.1. Проверка достижимости
Для проверки достижимости можно использовать метод `isTaskReachable`.

Например, проверим задачи из предыдущего листинга:
```ts
const boot = new AppBoot()
    .add([ taskA, taskB, taskD ])

console.log(
    boot.isTaskReachable(taskA), // true
    boot.isTaskReachable(taskB), // true
    boot.isTaskReachable(taskC), // false
    boot.isTaskReachable(taskD), // false
)
```

Эту проверку можно использовать в тестировании,
чтобы избежать ошибок в настоящей среде выполнения.

## 2.5. Запуск процесса
После настройки процесса, его можно запустить методом `runAsync`.
Как понятно из названия, метод асинхронный и возвращает `Promise`, который требует ожидания.
`Promise` вернет управление, когда процесс инициализации будет завершен.

```ts
const boot = new AppBoot().add([ 
    bootUpdateStartData,
    bootFetchRemoteConfiguration,
    bootFetchABTests,
    bootRestoreLastSessionData,
    bootInitInAppPurchases,
])

await boot.runAsync();
```

### 2.5.1. Результат выполнения процесса
`Promise` после выполнения также вернет объект
с информацией о том как выполнились задачи.

Так можно проверить сколько задач выполнились успешно:
```ts
const result = boot.runAsync();

console.log(
    result.success.length,
    result.failure.length,
    result.skipped.length,
    result.unreachable.length,
)
```

[⮜ 01 – Задачи](./01_TASKS.md) ● [Индекс](./README.md) ● [03 – Процесс ⮞](./02_PROCESS.md)